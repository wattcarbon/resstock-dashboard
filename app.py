#!/usr/bin/env python3
"""
ResStock Dashboard with Side-by-Side County Comparison
Each county gets its own complete dashboard with map and all visualizations
"""

import streamlit as st
import pandas as pd
import sqlite3
import plotly.express as px
import plotly.graph_objects as go
import json
import numpy as np
import requests
from io import StringIO
import os

DB_LOCAL_PATH = "resstock.db"
# This assumes that the sqlite file generated by `convert_to_sqlite.py` has been uploaded to S3
DB_URL = "https://wattcarbon-nrel-stock-dashboard.s3.us-west-2.amazonaws.com/resstock.db"

@st.cache_data
def download_db():
    if not os.path.exists(DB_LOCAL_PATH):
        with st.spinner("Downloading database..."):
            r = requests.get(DB_URL)
            r.raise_for_status()
            with open(DB_LOCAL_PATH, "wb") as f:
                f.write(r.content)
    return DB_LOCAL_PATH

db_path = download_db()

# Set page config
st.set_page_config(
    page_title="ResStock Dashboard - County Comparison",
    page_icon="üè†",
    layout="wide",
    initial_sidebar_state="expanded"
)


# Title
st.title("üè† ResStock Interactive County Comparison")
st.markdown("Compare building energy data between two counties with separate dashboards")

@st.cache_data
def load_counties_geojson():
    """Load the single counties GeoJSON file"""
    try:
        with open('counties.geojson', 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        st.error("‚ùå counties.geojson file not found!")
        return None
    except Exception as e:
        st.error(f"‚ùå Error loading counties.geojson: {e}")
        return None


@st.cache_data
def get_county_stats():
    """Get county statistics from summary table"""
    conn = sqlite3.connect(db_path)
    query = "SELECT * FROM county_summary ORDER BY in_county_name, in_state"
    stats = pd.read_sql_query(query, conn)
    conn.close()
    return stats

@st.cache_data
def get_county_building_stats():
    """Get county and building type statistics from summary table"""
    conn = sqlite3.connect(db_path)
    query = "SELECT * FROM county_building_summary ORDER BY in_county_name, in_state, in_geometry_building_type_recs"
    stats = pd.read_sql_query(query, conn)
    conn.close()
    return stats

@st.cache_data
def get_available_building_types():
    """Get list of available building types"""
    conn = sqlite3.connect(db_path)
    query = "SELECT DISTINCT in_geometry_building_type_recs FROM county_building_summary ORDER BY in_geometry_building_type_recs"
    building_types = pd.read_sql_query(query, conn)
    conn.close()
    return building_types['in_geometry_building_type_recs'].tolist()

@st.cache_data
def load_upgrades_lookup():
    """Load upgrades lookup from JSON file"""
    try:
        with open('upgrades_lookup.json', 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        st.error("‚ùå upgrades_lookup.json file not found!")
        return {}
    except Exception as e:
        st.error(f"‚ùå Error loading upgrades_lookup.json: {e}")
        return {}

@st.cache_data
def get_loadshape_data(state, upgrade, building_type, column_name=None):
    """Get loadshape data from database for a specific state, upgrade, and building type"""
    try:
        conn = sqlite3.connect(db_path)
        
        # Build query
        query = """
        SELECT hour_of_day, column_name, avg_value 
        FROM loadshape_summary 
        WHERE state = ? AND upgrade = ? AND building_type = ?
        """
        params = [state, upgrade, building_type]
        
        if column_name:
            query += " AND column_name = ?"
            params.append(column_name)
        
        query += " ORDER BY hour_of_day, column_name"
        
        # Execute query
        df = pd.read_sql_query(query, conn, params=params)
        conn.close()
        
        if len(df) == 0:
            return None
        
        # If no specific column requested, get the first available column
        if not column_name:
            available_columns = df['column_name'].unique()
            if len(available_columns) > 0:
                column_name = available_columns[0]
                df = df[df['column_name'] == column_name]
        
        # Create hourly series
        hourly_data = df.set_index('hour_of_day')['avg_value']
        
        return hourly_data
        
    except Exception as e:
        st.error(f"‚ùå Error fetching loadshape data for state={state}, upgrade={upgrade}, building_type={building_type}: {e}")
        return None

@st.cache_data
def get_available_loadshape_columns():
    """Get list of available column names in loadshape data"""
    try:
        conn = sqlite3.connect(db_path)
        query = "SELECT DISTINCT column_name FROM loadshape_summary ORDER BY column_name"
        columns = pd.read_sql_query(query, conn)
        conn.close()
        return columns['column_name'].tolist()
    except Exception as e:
        st.error(f"‚ùå Error fetching available loadshape columns: {e}")
        return []

@st.cache_data
def get_county_summary(county_name, state):
    """Get summary data for a specific county"""
    conn = sqlite3.connect(db_path)
    query = """
    SELECT * FROM county_summary 
    WHERE in_county_name = ? AND in_state = ?
    """
    data = pd.read_sql_query(query, conn, params=[county_name, state])
    conn.close()
    return data

@st.cache_data
def get_county_building_summary(county_name, state, building_types=None):
    """Get summary data for a specific county and building types"""
    conn = sqlite3.connect(db_path)
    
    if building_types and len(building_types) > 0:
        # Filter by selected building types
        placeholders = ','.join(['?' for _ in building_types])
        query = f"""
        SELECT * FROM county_building_summary 
        WHERE in_county_name = ? AND in_state = ? 
        AND in_geometry_building_type_recs IN ({placeholders})
        """
        params = [county_name, state] + building_types
    else:
        # Get all building types for the county
        query = """
        SELECT * FROM county_building_summary 
        WHERE in_county_name = ? AND in_state = ?
        """
        params = [county_name, state]
    
    data = pd.read_sql_query(query, conn, params=params)
    conn.close()
    return data

def parse_distribution(dist_str):
    """Parse distribution string into pandas Series for plotting"""
    # Handle pandas Series input
    if hasattr(dist_str, 'iloc'):
        dist_str = dist_str.iloc[0]
    
    if pd.isna(dist_str) or dist_str is None or dist_str == '':
        return pd.Series()
    
    try:
        # Parse "type1:count1,type2:count2" format
        items = dist_str.split(',')
        data = {}
        for item in items:
            if ':' in item:
                key, value = item.split(':', 1)
                data[key.strip()] = int(value.strip())
        return pd.Series(data)
    except:
        return pd.Series()

def get_distribution_config():
    """Configuration for distribution columns - update this to add new columns"""
    return {
        'in_geometry_building_type_recs': {
            'title': 'Building Types',
            'display_name': 'Building Type Distribution'
        },
        'in_heating_fuel': {
            'title': 'Heating Fuel',
            'display_name': 'Heating Fuel Distribution'
        },
        'in_water_heater_fuel': {
            'title': 'Water Heater Fuel',
            'display_name': 'Water Heater Fuel Distribution'
        },
        'in_vintage': {
            'title': 'Building Vintage',
            'display_name': 'Building Vintage Distribution'
        },
        # Add new columns here:
        # 'in_cooling_fuel': {
        #     'title': 'Cooling Fuel',
        #     'display_name': 'Cooling Fuel Distribution'
        # },
        # 'in_lighting_type': {
        #     'title': 'Lighting Type',
        #     'display_name': 'Lighting Type Distribution'
        # },
    }



def display_county_dashboard(county_stats, county_building_stats, selected_state_abbrev, selected_state, display_state, 
                           county_selector_label, county_selector_key, map_key, selected_building_types):
    """Display a complete county dashboard with map and all visualizations"""
    
    # Initialize selected_county_full to prevent UnboundLocalError
    selected_county_full = None
    
    # County selector (filtered by selected state)
    state_county_stats = county_stats[county_stats['in_state'] == selected_state_abbrev]
    state_counties = state_county_stats[['in_county_name', 'in_state']].drop_duplicates()
    
    if len(state_counties) == 0:
        st.error(f"No counties found for {selected_state_abbrev} ({selected_state})")
        return None
    
    # Filter county building stats by selected building types and state
    if selected_building_types and len(selected_building_types) > 0:
        filtered_building_stats = county_building_stats[
            (county_building_stats['in_state'] == selected_state_abbrev) & 
            (county_building_stats['in_geometry_building_type_recs'].isin(selected_building_types))
        ]
        
        # Aggregate by county for map
        map_data = filtered_building_stats.groupby(['in_county', 'in_county_name', 'in_state', 'fips']).agg({
            'building_count': 'sum',
            'weighted_count': 'sum'
        }).reset_index()
    else:
        # Use all building types
        map_data = county_building_stats[county_building_stats['in_state'] == selected_state_abbrev].groupby(
            ['in_county', 'in_county_name', 'in_state', 'fips']
        ).agg({
            'building_count': 'sum',
            'weighted_count': 'sum'
        }).reset_index()
    
    # Create county map using the counties.geojson file
    try:
        # Load counties GeoJSON data
        counties_geojson = load_counties_geojson()
        if counties_geojson is None:
            st.error("‚ùå Failed to load counties.geojson file")
            return None
        
        # Create the choropleth map using county IDs
        map_fig = px.choropleth(
            map_data,
            geojson=counties_geojson,
            locations='fips', 
            featureidkey='properties.GEO_ID',
            color='building_count',
            hover_name='in_county_name',
            hover_data=['in_state', 'building_count', 'weighted_count'],
            color_continuous_scale='YlOrRd',
            title=f"Building Count by County - {display_state} ({', '.join(selected_building_types) if selected_building_types else 'All Types'})",
            labels={'building_count': 'Building Count', 'weighted_count': 'Weighted Count'}
        )
        
        map_fig.update_geos(
            scope="usa",
            showland=True,
            landcolor="lightgray",
            showocean=True,
            oceancolor="lightblue",
            showlakes=True,
            lakecolor="lightblue"
        )
        
        map_fig.update_layout(
            height=400,
            margin={"r":0,"t":30,"l":0,"b":0}
        )
        
        st.plotly_chart(map_fig, use_container_width=True, key=f"map_{map_key}")
    except Exception as e:
        st.error(f"‚ùå Map Error: {e}")
        st.info("Note: County mapping requires county_id values in the 'in_county' column that match the GeoJSON properties")
    
    # County dropdown below the map - use filtered data
    county_options = [f"{row['in_county_name']}, {row['in_state']}" for _, row in map_data.iterrows()]
    
    if len(county_options) == 0:
        st.error(f"No counties found with selected building types for {selected_state_abbrev} ({selected_state})")
        return None
    
    # Set default index based on the dashboard side and state
    default_index = 0
    if map_key == "county1" and selected_state_abbrev == "CA":
        # Default to Alameda County for County 1 in CA
        try:
            default_index = county_options.index("Alameda County, CA")
        except ValueError:
            default_index = 0
    elif map_key == "county2" and selected_state_abbrev == "GA":
        # Default to Fulton County for County 2 in GA
        try:
            default_index = county_options.index("Fulton County, GA")
        except ValueError:
            default_index = 0
    
    selected_county_full = st.selectbox(
        county_selector_label,
        options=sorted(county_options),
        index=default_index,
        key=county_selector_key
    )
    
    if selected_county_full is None:
        st.error("No county selected. Please check the state filter.")
        return None
    
    # Extract county name from selection
    selected_county = selected_county_full.split(", ")[0]
    selected_state_from_selection = selected_county_full.split(", ")[1]
    
    # Show county info using filtered data
    county_data = map_data[
        (map_data['in_county_name'] == selected_county) & 
        (map_data['in_state'] == selected_state_abbrev)
    ].iloc[0]
    
    st.info(f"**{selected_county}, {display_state}** (ID: {county_data['in_county']})")
    
    # Display key metrics using TOTAL (non-filtered) data
    col_1, col_2 = st.columns(2)
    
    # Get total building counts (all building types)
    total_county_building_summary = get_county_building_summary(selected_county, display_state, None)  # None = all building types
    if total_county_building_summary is not None and len(total_county_building_summary) > 0:
        total_building_count = total_county_building_summary['building_count'].sum()
        total_weighted_count = total_county_building_summary['weighted_count'].sum()
    else:
        total_building_count = 0
        total_weighted_count = 0
    
    with col_1:
        st.metric(
            label="# of Building Models (Total)",
            value=f"{total_building_count:,}",
            help="Total number of all building types in the dataset for this county"
        )
    
    with col_2:
        st.metric(
            label="# of Buildings Represented (Total)",
            value=f"{total_weighted_count:,.0f}",
            help="Total weighted count representing actual building population for all building types"
        )
    
    # Building Type Distribution - show ALL building types for this county (on its own line)
    if total_county_building_summary is not None and len(total_county_building_summary) > 0:
        # Use the actual building counts from the data
        building_type_data = total_county_building_summary[['in_geometry_building_type_recs', 'building_count']].copy()
        building_type_data = building_type_data.groupby('in_geometry_building_type_recs')['building_count'].sum().reset_index()
        
        if len(building_type_data) > 0:
            fig = px.pie(
                values=building_type_data['building_count'],
                names=building_type_data['in_geometry_building_type_recs'],
                title="All Building Types in County"
            )
            st.plotly_chart(fig, use_container_width=True, key=f"{map_key}_all_building_types")
        else:
            st.info("Building Type data not available")
    else:
        st.info("Building Type data not available")
    
    # Get county summary data for selected building types
    county_building_summary = get_county_building_summary(selected_county, display_state, selected_building_types)
    
    if county_building_summary is not None and len(county_building_summary) > 0:
        # Aggregate the data across building types
        county_summary_agg = county_building_summary.agg({
            'building_count': 'sum',
            'weighted_count': 'sum',
            'avg_floor_area': lambda x: (x * county_building_summary['building_count']).sum() / county_building_summary['building_count'].sum() if x.notna().any() else None,
            'avg_vintage': lambda x: (x * county_building_summary['building_count']).sum() / county_building_summary['building_count'].sum() if x.notna().any() else None,
            'avg_electricity_kwh': lambda x: (x * county_building_summary['building_count']).sum() / county_building_summary['building_count'].sum() if x.notna().any() else None,
            'avg_electric_bill': lambda x: (x * county_building_summary['building_count']).sum() / county_building_summary['building_count'].sum() if x.notna().any() else None,
            'avg_energy_burden': lambda x: (x * county_building_summary['building_count']).sum() / county_building_summary['building_count'].sum() if x.notna().any() else None,
        }).to_frame().T
        
        # Add county info
        county_summary_agg['in_county_name'] = selected_county
        county_summary_agg['in_state'] = display_state
        
        # Get most common values (simplified - just take the first one for now)
        county_summary_agg['most_common_building_type'] = county_building_summary['in_geometry_building_type_recs'].mode().iloc[0] if len(county_building_summary['in_geometry_building_type_recs'].mode()) > 0 else None
        county_summary_agg['most_common_heating_fuel'] = county_building_summary['most_common_heating_fuel'].mode().iloc[0] if len(county_building_summary['most_common_heating_fuel'].mode()) > 0 else None
        county_summary_agg['most_common_water_heater_fuel'] = county_building_summary['most_common_water_heater_fuel'].mode().iloc[0] if len(county_building_summary['most_common_water_heater_fuel'].mode()) > 0 else None
        
        # Aggregate distribution data
        distribution_data = {}
        for col in ['in_heating_fuel_dist', 'in_water_heater_fuel_dist', 'in_vintage_dist']:
            if col in county_building_summary.columns:
                all_distributions = county_building_summary[col].dropna()
                if len(all_distributions) > 0:
                    # Combine all distributions
                    combined_dist = {}
                    for dist_str in all_distributions:
                        if dist_str:
                            dist_data = parse_distribution(dist_str)
                            for key, value in dist_data.items():
                                combined_dist[key] = combined_dist.get(key, 0) + value
                    
                    # Convert back to string format
                    distribution_data[col] = ','.join([f"{k}:{v}" for k, v in combined_dist.items()])
                else:
                    distribution_data[col] = None
            else:
                distribution_data[col] = None
        
        # Add distribution data to the DataFrame
        for key, value in distribution_data.items():
            county_summary_agg[key] = value
        
        county_summary = county_summary_agg
        
        # Filtered building counts
        st.subheader("üìä Filtered Buildings")
        st.write(f"**Filtered by:** {', '.join(selected_building_types) if selected_building_types else 'All Types'}")
        
        col_filtered_1, col_filtered_2 = st.columns(2)
        
        with col_filtered_1:
            st.metric(
                label="# of Building Models (Filtered)",
                value=f"{county_data['building_count']:,}",
                help=f"Number of {', '.join(selected_building_types) if selected_building_types else 'all'} building types in the dataset for this county"
            )
        
        with col_filtered_2:
            st.metric(
                label="# of Buildings Represented (Filtered)",
                value=f"{county_data['weighted_count']:,.0f}",
                help=f"Weighted count representing actual {', '.join(selected_building_types) if selected_building_types else 'all'} building population"
            )
        
        # Create filtered distribution charts
        st.subheader("üìä Distribution Charts")
        
        # First row: Vintage and Heating Fuel
        col_dist1, col_dist2 = st.columns(2)
        
        with col_dist1:
            # Vintage Distribution (Bar Chart)
            dist_key = 'in_vintage_dist'
            if dist_key in county_summary:
                dist_data = parse_distribution(county_summary[dist_key])
                if len(dist_data) > 0:
                    # Sort by NREL building vintage order
                    nrel_vintage_order = [
                        "<1940",
                        "1940s",
                        "1950s",
                        "1960s",
                        "1970s",
                        "1980s",
                        "1990s",
                        "2000s",
                        "2010s",
                    ]
                    
                    # Reorder the data according to NREL vintage order
                    sorted_data = {}
                    for vintage in nrel_vintage_order:
                        if vintage in dist_data.index:
                            sorted_data[vintage] = dist_data[vintage]
                    
                    # Create sorted series
                    sorted_dist_data = pd.Series(sorted_data)
                    
                    fig = px.bar(
                        x=sorted_dist_data.index,
                        y=sorted_dist_data.values,
                        title="Building Vintage Distribution (Filtered)",
                        labels={'x': 'Vintage Year', 'y': 'Number of Buildings'}
                    )
                    st.plotly_chart(fig, use_container_width=True, key=f"{map_key}_vintage")
                else:
                    st.info("Vintage data not available")
            else:
                st.info("Vintage data not available")
        
        with col_dist2:
            # Heating Fuel Distribution
            dist_key = 'in_heating_fuel_dist'
            if dist_key in county_summary:
                dist_data = parse_distribution(county_summary[dist_key])
                if len(dist_data) > 0:
                    fig = px.pie(
                        values=dist_data.values,
                        names=dist_data.index,
                        title="Heating Fuel Distribution (Filtered)"
                    )
                    st.plotly_chart(fig, use_container_width=True, key=f"{map_key}_heating_fuel")
                else:
                    st.info("Heating Fuel data not available")
            else:
                st.info("Heating Fuel data not available")
        
        # Second row: Water Heater Fuel
        col_dist3, col_dist4 = st.columns(2)
        
        with col_dist3:
            # Water Heater Fuel Distribution
            dist_key = 'in_water_heater_fuel_dist'
            if dist_key in county_summary:
                dist_data = parse_distribution(county_summary[dist_key])
                if len(dist_data) > 0:
                    fig = px.pie(
                        values=dist_data.values,
                        names=dist_data.index,
                        title="Water Heater Fuel Distribution (Filtered)"
                    )
                    st.plotly_chart(fig, use_container_width=True, key=f"{map_key}_water_heater_fuel")
                else:
                    st.info("Water Heater Fuel data not available")
            else:
                st.info("Water Heater Fuel data not available")
        
        with col_dist4:
            # Empty column for future use
            st.empty()
        
        # Energy metrics
        st.subheader("üîç Energy Insights")
        
        col4_1, col4_2, col4_3 = st.columns(3)
        
        with col4_1:
            st.write("**Energy Consumption (kWh)**")
            if pd.notna(county_summary['avg_electricity_kwh'].iloc[0]) and county_summary['avg_electricity_kwh'].iloc[0] is not None:
                st.metric("Avg Electricity", f"{county_summary['avg_electricity_kwh'].iloc[0]:,.0f}")
            else:
                st.metric("Avg Electricity", "N/A")
        
        with col4_2:
            st.write("**Energy Costs ($)**")
            if pd.notna(county_summary['avg_electric_bill'].iloc[0]) and county_summary['avg_electric_bill'].iloc[0] is not None:
                st.metric("Avg Electric Bill", f"${county_summary['avg_electric_bill'].iloc[0]:.0f}")
            else:
                st.metric("Avg Electric Bill", "N/A")
        
        with col4_3:
            st.write("**Energy Burden (%)**")
            if pd.notna(county_summary['avg_energy_burden'].iloc[0]) and county_summary['avg_energy_burden'].iloc[0] is not None:
                st.metric("Avg Energy Burden", f"{county_summary['avg_energy_burden'].iloc[0]:.1f}%")
            else:
                st.metric("Avg Energy Burden", "N/A")
        
        # Energy Characteristics
        st.subheader("‚ö° Energy Characteristics")
        
        if pd.notna(county_summary['most_common_heating_fuel'].iloc[0]) and county_summary['most_common_heating_fuel'].iloc[0] is not None:
            st.metric("Primary Heating Fuel", county_summary['most_common_heating_fuel'].iloc[0])
        else:
            st.metric("Primary Heating Fuel", "N/A")
        
        # County summary table
        st.subheader(f"üìã County Summary - {selected_county}, {display_state}")
        
        # Create a summary table
        summary_data = {
            'Metric': [
                'Total Buildings',
                'Weighted Buildings', 
                'Average Vintage',
                'Average Electricity (kWh)',
                'Average Electric Bill ($)',
                'Average Energy Burden (%)',
                'Most Common Building Type',
                'Most Common Heating Fuel',
                'Most Common Water Heater Fuel'
            ],
            'Value': [
                f"{county_summary['building_count'].iloc[0]:,}",
                f"{county_summary['weighted_count'].iloc[0]:,.0f}",
                f"{county_summary['avg_vintage'].iloc[0]:.0f}" if pd.notna(county_summary['avg_vintage'].iloc[0]) and county_summary['avg_vintage'].iloc[0] is not None else "N/A",
                f"{county_summary['avg_electricity_kwh'].iloc[0]:,.0f}" if pd.notna(county_summary['avg_electricity_kwh'].iloc[0]) and county_summary['avg_electricity_kwh'].iloc[0] is not None else "N/A",
                f"{county_summary['avg_electric_bill'].iloc[0]:.0f}" if pd.notna(county_summary['avg_electric_bill'].iloc[0]) and county_summary['avg_electric_bill'].iloc[0] is not None else "N/A",
                f"{county_summary['avg_energy_burden'].iloc[0]:.1f}%" if pd.notna(county_summary['avg_energy_burden'].iloc[0]) and county_summary['avg_energy_burden'].iloc[0] is not None else "N/A",
                county_summary['most_common_building_type'].iloc[0] if pd.notna(county_summary['most_common_building_type'].iloc[0]) else "N/A",
                county_summary['most_common_heating_fuel'].iloc[0] if pd.notna(county_summary['most_common_heating_fuel'].iloc[0]) else "N/A",
                county_summary['most_common_water_heater_fuel'].iloc[0] if pd.notna(county_summary['most_common_water_heater_fuel'].iloc[0]) else "N/A"
            ]
        }
        
        summary_df = pd.DataFrame(summary_data)
        st.dataframe(summary_df, use_container_width=True, key=f"table_{map_key}")
    else:
        st.warning("No data available for selected county")
    
    return selected_county, display_state

def main():
    # Check if database exists
    try:
        conn = sqlite3.connect('resstock.db')
        conn.close()
    except Exception as e:
        st.error(f"‚ùå Database Error: {e}")
        st.error("‚ùå SQLite database not found! Please run `python convert_to_sqlite.py` first.")
        st.stop()
    
    # Load data
    try:
        county_stats = get_county_stats()
        county_building_stats = get_county_building_stats()
    except Exception as e:
        st.error(f"‚ùå County Stats Error: {e}")
        st.stop()
    
    # Get available building types
    try:
        available_building_types = get_available_building_types()
    except Exception as e:
        st.error(f"‚ùå Building Types Error: {e}")
        st.stop()
    
    # Load upgrades lookup
    try:
        upgrades_lookup = load_upgrades_lookup()
    except Exception as e:
        st.error(f"‚ùå Upgrades Lookup Error: {e}")
        st.stop()
    
    # Building type filter at the top of the page
    st.subheader("üèóÔ∏è Building Type Filter")
    
    # Add custom CSS to make the multiselect font smaller
    st.markdown("""
    <style>
    .stMultiSelect option {
        font-size: 10px !important;
    }
    div[data-baseweb="select"] span {
        font-size: 10px !important;
    }
    </style>
    """, unsafe_allow_html=True)
    
    selected_building_types = st.multiselect(
        "Select building types to include:",
        options=available_building_types,
        default=available_building_types,  # Default to all building types
        help="Select which building types to include in the analysis. Leave all selected to see all building types."
    )
    
    # Show current filter status
    if selected_building_types:
        st.success(f"‚úÖ Filtering by: {', '.join(selected_building_types)}")
    else:
        st.warning("‚ö†Ô∏è No building types selected - showing all types")
    
    # State lookup tables
    state_lookup = pd.read_csv('state_lookup.csv')
    state_abbrev_to_name = dict(zip(state_lookup['state_abbrev'], state_lookup['state_name']))
    state_name_to_abbrev = dict(zip(state_lookup['state_name'], state_lookup['state_abbrev']))
    
    # Get unique states from data and convert to abbreviations
    unique_states = sorted(county_stats['in_state'].unique())
    state_abbrevs = [state_name_to_abbrev.get(state, state) for state in unique_states]
    
    # Create two columns for completely separate dashboards
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("üè† County 1 Dashboard")
        
        # Separate state filter for County 1
        selected_state_abbrev_1 = st.selectbox(
            "Select State for County 1:",
            options=state_abbrevs,
            index=state_abbrevs.index('CA') if 'CA' in state_abbrevs else 0,
            key="state1_selector"
        )
        
        # Convert back to full state name for filtering data
        selected_state_1 = state_abbrev_to_name.get(selected_state_abbrev_1, selected_state_abbrev_1)
        
        # Check if we need to filter by abbreviation or full name
        if selected_state_abbrev_1 in county_stats['in_state'].values:
            # Data uses abbreviations
            display_state_1 = selected_state_abbrev_1
        else:
            # Data uses full names
            display_state_1 = selected_state_1
        
        st.write(f"üìä Showing counties in {display_state_1}")
        
        county1_data = display_county_dashboard(
            county_stats,
            county_building_stats,
            selected_state_abbrev_1, 
            selected_state_1, 
            display_state_1,
            f"Select County 1 in {selected_state_abbrev_1}:",
            "county1_selector",
            "county1",
            selected_building_types
        )
    
    with col2:
        st.subheader("üè† County 2 Dashboard")
        
        # Separate state filter for County 2
        selected_state_abbrev_2 = st.selectbox(
            "Select State for County 2:",
            options=state_abbrevs,
            index=state_abbrevs.index('GA') if 'GA' in state_abbrevs else 0,
            key="state2_selector"
        )
        
        # Convert back to full state name for filtering data
        selected_state_2 = state_abbrev_to_name.get(selected_state_abbrev_2, selected_state_abbrev_2)
        
        # Check if we need to filter by abbreviation or full name
        if selected_state_abbrev_2 in county_stats['in_state'].values:
            # Data uses abbreviations
            display_state_2 = selected_state_abbrev_2
        else:
            # Data uses full names
            display_state_2 = selected_state_2
        
        st.write(f"üìä Showing counties in {display_state_2}")
        
        county2_data = display_county_dashboard(
            county_stats,
            county_building_stats,
            selected_state_abbrev_2, 
            selected_state_2, 
            display_state_2,
            f"Select County 2 in {selected_state_abbrev_2}:",
            "county2_selector",
            "county2",
            selected_building_types
        )
    
    # Loadshape Analysis Section
    st.subheader("üìä Loadshape Analysis")
    
    # Check if loadshape data is available
    available_columns = get_available_loadshape_columns()
    
    if not available_columns:
        st.warning("‚ö†Ô∏è No loadshape data found in database. Please run `python convert_to_sqlite.py loadshape` to create loadshape summaries.")
    else:
        # Get the selected states from the dashboard
        selected_states = []
        if county1_data:
            selected_states.append(county1_data[1])  # county1_state
        if county2_data:
            selected_states.append(county2_data[1])  # county2_state
        selected_states = list(set(selected_states))  # Remove duplicates
        
        if selected_states:
            # Upgrade selector
            upgrade_options = list(upgrades_lookup.keys())
            
            # Filter selectors - one per line
            selected_upgrade = st.selectbox(
                "Select Upgrade to Compare with Baseline:",
                options=upgrade_options,
                index=1,  # Default to upgrade 1
                format_func=lambda x: f"{x}: {upgrades_lookup[x]}",
                help="Select an upgrade scenario to compare with the baseline (upgrade=0)"
            )
            
            # Fuel selector
            fuel_options = ['propane', 'natural_gas', 'fuel_oil']
            selected_fuel = st.selectbox(
                "Select Non-Electric Fuel to Display:",
                options=fuel_options,
                index=1,  # Default to natural_gas
                help="Select which fuel type to display"
            )
            
            # Emissions scenario selector
            emissions_options = ['midcase_15', 'lowrecost_15', 'highrecost_15']
            selected_emissions = st.selectbox(
                "Select Emissions Scenario:",
                options=emissions_options,
                index=0,  # Default to midcase_15
                help="Select which emissions cost scenario to display"
            )
            
            # Available columns information
            st.write("**Available Columns:**")
            st.write(f"‚Ä¢ Electricity: `out.electricity.total.energy_consumption.kwh`")
            st.write(f"‚Ä¢ Fuel: `out.{selected_fuel}.total.energy_consumption.kwh`")
            st.write(f"‚Ä¢ Emissions: `out.emissions.all_fuels.lrmer_{selected_emissions}.co2e_kg`")
            
            # Create separate columns for each state (like the county dashboards)
            if len(selected_states) == 1:
                # Single state - use full width
                state_cols = [st.container()]
            else:
                # Multiple states - create columns
                state_cols = st.columns(len(selected_states))
            
            for i, state in enumerate(selected_states):
                with state_cols[i]:
                    st.write(f"**{state} Loadshape Analysis**")
                    
                    # Electricity chart (top)
                    st.write("**Electricity Consumption**")
                    
                    # Sum up all building types for electricity
                    baseline_electricity_sum = None
                    upgrade_electricity_sum = None
                    
                    for building_type in selected_building_types:
                        # Fetch baseline electricity data (upgrade=0)
                        baseline_data = get_loadshape_data(state, 0, building_type, 'out.electricity.total.energy_consumption.kwh')
                        
                        # Fetch selected upgrade electricity data
                        upgrade_data = get_loadshape_data(state, int(selected_upgrade), building_type, 'out.electricity.total.energy_consumption.kwh')
                        
                        if baseline_data is not None:
                            if baseline_electricity_sum is None:
                                baseline_electricity_sum = baseline_data
                            else:
                                baseline_electricity_sum = baseline_electricity_sum.add(baseline_data, fill_value=0)
                        
                        if upgrade_data is not None:
                            if upgrade_electricity_sum is None:
                                upgrade_electricity_sum = upgrade_data
                            else:
                                upgrade_electricity_sum = upgrade_electricity_sum.add(upgrade_data, fill_value=0)
                    
                    # Create electricity chart
                    if baseline_electricity_sum is not None and upgrade_electricity_sum is not None:
                        fig_electricity = go.Figure()
                        
                        # Add baseline trace
                        fig_electricity.add_trace(go.Scatter(
                            x=baseline_electricity_sum.index,
                            y=baseline_electricity_sum.values,
                            mode='lines+markers',
                            name=f"Baseline (upgrade=0)",
                            line=dict(width=2, color='blue'),
                            marker=dict(size=6)
                        ))
                        
                        # Add upgrade trace
                        fig_electricity.add_trace(go.Scatter(
                            x=upgrade_electricity_sum.index,
                            y=upgrade_electricity_sum.values,
                            mode='lines+markers',
                            name=f"{upgrades_lookup[selected_upgrade]} (upgrade={selected_upgrade})",
                            line=dict(width=2, color='red', dash='dash'),
                            marker=dict(size=6, symbol='diamond')
                        ))
                        
                        # Update layout
                        fig_electricity.update_layout(
                            title=f"Electricity - {state}",
                            xaxis_title="Hour of Day",
                            yaxis_title="Total Electricity (kWh)",
                            height=300,
                            showlegend=True,
                            legend=dict(
                                orientation="h",
                                yanchor="bottom",
                                y=1.02,
                                xanchor="right",
                                x=1
                            )
                        )
                        
                        # Update x-axis to show all hours
                        fig_electricity.update_xaxes(tickmode='linear', tick0=0, dtick=1, range=[0, 23])
                        
                        st.plotly_chart(fig_electricity, use_container_width=True)
                    else:
                        st.warning(f"No electricity data available for {state}")
                    
                    # Fuel chart (middle)
                    st.write(f"**{selected_fuel.replace('_', ' ').title()} Consumption**")
                    
                    # Sum up all building types for fuel
                    baseline_fuel_sum = None
                    upgrade_fuel_sum = None
                    
                    fuel_column = f"out.{selected_fuel}.total.energy_consumption.kwh"
                    
                    for building_type in selected_building_types:
                        # Fetch baseline fuel data (upgrade=0)
                        baseline_data = get_loadshape_data(state, 0, building_type, fuel_column)
                        
                        # Fetch selected upgrade fuel data
                        upgrade_data = get_loadshape_data(state, int(selected_upgrade), building_type, fuel_column)
                        
                        if baseline_data is not None:
                            if baseline_fuel_sum is None:
                                baseline_fuel_sum = baseline_data
                            else:
                                baseline_fuel_sum = baseline_fuel_sum.add(baseline_data, fill_value=0)
                        
                        if upgrade_data is not None:
                            if upgrade_fuel_sum is None:
                                upgrade_fuel_sum = upgrade_data
                            else:
                                upgrade_fuel_sum = upgrade_fuel_sum.add(upgrade_data, fill_value=0)
                    
                    # Create fuel chart
                    if baseline_fuel_sum is not None and upgrade_fuel_sum is not None:
                        fig_fuel = go.Figure()
                        
                        # Add baseline trace
                        fig_fuel.add_trace(go.Scatter(
                            x=baseline_fuel_sum.index,
                            y=baseline_fuel_sum.values,
                            mode='lines+markers',
                            name=f"Baseline (upgrade=0)",
                            line=dict(width=2, color='blue'),
                            marker=dict(size=6)
                        ))
                        
                        # Add upgrade trace
                        fig_fuel.add_trace(go.Scatter(
                            x=upgrade_fuel_sum.index,
                            y=upgrade_fuel_sum.values,
                            mode='lines+markers',
                            name=f"{upgrades_lookup[selected_upgrade]} (upgrade={selected_upgrade})",
                            line=dict(width=2, color='red', dash='dash'),
                            marker=dict(size=6, symbol='diamond')
                        ))
                        
                        # Update layout
                        fig_fuel.update_layout(
                            title=f"{selected_fuel.replace('_', ' ').title()} - {state}",
                            xaxis_title="Hour of Day",
                            yaxis_title=f"Total {selected_fuel.replace('_', ' ').title()} (kWh)",
                            height=300,
                            showlegend=True,
                            legend=dict(
                                orientation="h",
                                yanchor="bottom",
                                y=1.02,
                                xanchor="right",
                                x=1
                            )
                        )
                        
                        # Update x-axis to show all hours
                        fig_fuel.update_xaxes(tickmode='linear', tick0=0, dtick=1, range=[0, 23])
                        
                        st.plotly_chart(fig_fuel, use_container_width=True)
                    else:
                        st.warning(f"No {selected_fuel} data available for {state}")
                    
                    # Emissions chart (bottom)
                    st.write(f"**Emissions ({selected_emissions.replace('_', ' ').title()})**")
                    
                    # Sum up all building types for emissions
                    baseline_emissions_sum = None
                    upgrade_emissions_sum = None
                    
                    emissions_column = f"out.emissions.all_fuels.lrmer_{selected_emissions}.co2e_kg"
                    
                    for building_type in selected_building_types:
                        # Fetch baseline emissions data (upgrade=0)
                        baseline_data = get_loadshape_data(state, 0, building_type, emissions_column)
                        
                        # Fetch selected upgrade emissions data
                        upgrade_data = get_loadshape_data(state, int(selected_upgrade), building_type, emissions_column)
                        
                        if baseline_data is not None:
                            if baseline_emissions_sum is None:
                                baseline_emissions_sum = baseline_data
                            else:
                                baseline_emissions_sum = baseline_emissions_sum.add(baseline_data, fill_value=0)
                        
                        if upgrade_data is not None:
                            if upgrade_emissions_sum is None:
                                upgrade_emissions_sum = upgrade_data
                            else:
                                upgrade_emissions_sum = upgrade_emissions_sum.add(upgrade_data, fill_value=0)
                    
                    # Create emissions chart
                    if baseline_emissions_sum is not None and upgrade_emissions_sum is not None:
                        fig_emissions = go.Figure()
                        
                        # Add baseline trace
                        fig_emissions.add_trace(go.Scatter(
                            x=baseline_emissions_sum.index,
                            y=baseline_emissions_sum.values,
                            mode='lines+markers',
                            name=f"Baseline (upgrade=0)",
                            line=dict(width=2, color='blue'),
                            marker=dict(size=6)
                        ))
                        
                        # Add upgrade trace
                        fig_emissions.add_trace(go.Scatter(
                            x=upgrade_emissions_sum.index,
                            y=upgrade_emissions_sum.values,
                            mode='lines+markers',
                            name=f"{upgrades_lookup[selected_upgrade]} (upgrade={selected_upgrade})",
                            line=dict(width=2, color='red', dash='dash'),
                            marker=dict(size=6, symbol='diamond')
                        ))
                        
                        # Update layout
                        fig_emissions.update_layout(
                            title=f"Emissions ({selected_emissions.replace('_', ' ').title()}) - {state}",
                            xaxis_title="Hour of Day",
                            yaxis_title="CO2e Emissions (kg)",
                            height=300,
                            showlegend=True,
                            legend=dict(
                                orientation="h",
                                yanchor="bottom",
                                y=1.02,
                                xanchor="right",
                                x=1
                            )
                        )
                        
                        # Update x-axis to show all hours
                        fig_emissions.update_xaxes(tickmode='linear', tick0=0, dtick=1, range=[0, 23])
                        
                        st.plotly_chart(fig_emissions, use_container_width=True)
                    else:
                        st.warning(f"No emissions data available for {state}")
                    
                    # Show summary for this state
                    st.write("**Data Summary:**")
                    st.write(f"‚Ä¢ **State:** {state}")
                    st.write(f"‚Ä¢ **Building Types:** {', '.join(selected_building_types)}")
                    st.write(f"‚Ä¢ **Electricity:** out.electricity.total.energy_consumption.kwh")
                    st.write(f"‚Ä¢ **Fuel:** out.{selected_fuel}.total.energy_consumption.kwh")
                    st.write(f"‚Ä¢ **Emissions:** out.emissions.all_fuels.lrmer_{selected_emissions}.co2e_kg")
                    st.write(f"‚Ä¢ **Upgrade:** {selected_upgrade} - {upgrades_lookup[selected_upgrade]}")
                    st.write("**Data Source:** Database (pre-processed hourly averages)")
                    
                    st.divider()
        else:
            st.info("Please select counties in both dashboards to see loadshape analysis")
    
    # Add comparison section if both counties are selected
    if county1_data and county2_data:
        county1_name, county1_state = county1_data
        county2_name, county2_state = county2_data
        
        st.subheader("üîç Side-by-Side Comparison")
        
        # Get data for both counties with building type filtering
        county1_building_summary = get_county_building_summary(county1_name, county1_state, selected_building_types)
        county2_building_summary = get_county_building_summary(county2_name, county2_state, selected_building_types)
        
        # Aggregate the data for comparison
        if county1_building_summary is not None and len(county1_building_summary) > 0:
            county1_summary = county1_building_summary.agg({
                'building_count': 'sum',
                'weighted_count': 'sum',
                'avg_electricity_kwh': lambda x: (x * county1_building_summary['building_count']).sum() / county1_building_summary['building_count'].sum() if x.notna().any() else None,
                'avg_energy_burden': lambda x: (x * county1_building_summary['building_count']).sum() / county1_building_summary['building_count'].sum() if x.notna().any() else None,
            }).to_frame().T
        else:
            county1_summary = None
            
        if county2_building_summary is not None and len(county2_building_summary) > 0:
            county2_summary = county2_building_summary.agg({
                'building_count': 'sum',
                'weighted_count': 'sum',
                'avg_electricity_kwh': lambda x: (x * county2_building_summary['building_count']).sum() / county2_building_summary['building_count'].sum() if x.notna().any() else None,
                'avg_energy_burden': lambda x: (x * county2_building_summary['building_count']).sum() / county2_building_summary['building_count'].sum() if x.notna().any() else None,
            }).to_frame().T
        else:
            county2_summary = None
        
        if county1_summary is not None and county2_summary is not None:
            # Create comparison metrics
            comp_col1, comp_col2, comp_col3 = st.columns(3)
            
            with comp_col1:
                st.write("**Building Count Comparison**")
                st.metric(
                    f"{county1_name}",
                    f"{county1_summary['building_count'].iloc[0]:,}",
                    delta=f"{county1_summary['building_count'].iloc[0] - county2_summary['building_count'].iloc[0]:,}"
                )
                st.metric(
                    f"{county2_name}",
                    f"{county2_summary['building_count'].iloc[0]:,}",
                    delta=f"{county2_summary['building_count'].iloc[0] - county1_summary['building_count'].iloc[0]:,}"
                )
            

            
            with comp_col2:
                st.write("**Average Electricity Comparison**")
                if (pd.notna(county1_summary['avg_electricity_kwh'].iloc[0]) and county1_summary['avg_electricity_kwh'].iloc[0] is not None and
                    pd.notna(county2_summary['avg_electricity_kwh'].iloc[0]) and county2_summary['avg_electricity_kwh'].iloc[0] is not None):
                    st.metric(
                        f"{county1_name}",
                        f"{county1_summary['avg_electricity_kwh'].iloc[0]:,.0f} kWh",
                        delta=f"{county1_summary['avg_electricity_kwh'].iloc[0] - county2_summary['avg_electricity_kwh'].iloc[0]:,.0f}"
                    )
                    st.metric(
                        f"{county2_name}",
                        f"{county2_summary['avg_electricity_kwh'].iloc[0]:,.0f} kWh",
                        delta=f"{county2_summary['avg_electricity_kwh'].iloc[0] - county1_summary['avg_electricity_kwh'].iloc[0]:,.0f}"
                    )
                else:
                    st.info("Electricity data not available for comparison")
            
            with comp_col3:
                st.write("**Average Energy Burden Comparison**")
                if (pd.notna(county1_summary['avg_energy_burden'].iloc[0]) and county1_summary['avg_energy_burden'].iloc[0] is not None and
                    pd.notna(county2_summary['avg_energy_burden'].iloc[0]) and county2_summary['avg_energy_burden'].iloc[0] is not None):
                    st.metric(
                        f"{county1_name}",
                        f"{county1_summary['avg_energy_burden'].iloc[0]:.1f}%",
                        delta=f"{county1_summary['avg_energy_burden'].iloc[0] - county2_summary['avg_energy_burden'].iloc[0]:.1f}"
                    )
                    st.metric(
                        f"{county2_name}",
                        f"{county2_summary['avg_energy_burden'].iloc[0]:.1f}%",
                        delta=f"{county2_summary['avg_energy_burden'].iloc[0] - county1_summary['avg_energy_burden'].iloc[0]:.1f}"
                    )
                else:
                    st.info("Energy burden data not available for comparison")
    
if __name__ == "__main__":
    main() 
